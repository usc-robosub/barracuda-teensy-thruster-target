# barracuda-teensy
I2C target (on Teensy) that interfaces with the barracuda-thrusters. Utilized by each of the two Teensys (each is responsible for generating PWM signals for 4 of the 8 ESCs). If pin 2 is connected to the ground pin, the I2C address 0x2d will be assigned to the Teensy; otherwise, 0x2e will be assigned.

The barracuda_thrusters node sends each of the Teensys force values; the Teensys are responsible for converting these force values into PWM signals, and then outputting PWM signals on pins connected to the the ESCs. Each Teensy is responsible for outputting PWM signals for 4 thrusters: the Teensy assigned I2C address 0x2d has 4 of its PWM pins connected to the ESCs of thrusters 0-3, and the Teensy assigned I2C address 0x2e has 4 of its PWM pins connected to the ESCs of thrusters 4-7. The PWM pins on both the Teensys are pins 0, 1, 4, and 5. 

On the Teensy 4.0, the PWM frequency and bit resolution are both configurable in software. The frequency defines the max width of a pulse (a 100% duty cycle corresponds with width (s) of 1/(frequency (Hz)). The bit resolution defines how many discrete pulse widths can be output by the PWM pins: for a bit resolution of n, there are 2^n discrete pulse widths that can be output on the PWM pins, which correspond with duty cycles of 0/(2^n), 1/(2^n), ... (2^n)/(2^n). We set the pulse width on a PWM pin using analogWrite(pwm_pin, x), where x is an int and the duty cycle is x/(2^n).

Blue Robotics provides a force to pulse width conversion table for the T200 thrusters their website, which is stored as t200_18v_data.csv in this repo. Since we know which pulse widths the Teensy is capable of outputting, we can map each possible pulse width to the corresponding force using the conversion chart. To do this, we fit a curve through the points on the pulse width vs force graph, then we evaluate this function at the pulse widths that are achievable by the Teensys. Each pulse width achieveable by the Teensys is identified by an int x, where x/(2^(bit resolution)) gives the duty cycle of the PWM signal. 

This gives us a lookup table of all of these "x" values mapped to the force that will be generated by a thruster when we call analogWrite(pwm_pin, x). When a Teensy receives a force value f over I2C from the barracuda_thrusters node, we search the forces in the lookup table for the one closest to f (call that f_closest), and then call analogWrite(pwm_pin, x) for the x mapped to f_closest.

### Flashing the Teensy (With Arduino IDE)
1. Install the [Arduino IDE](https://www.arduino.cc/en/software/).
   - If you are using an Apple Silicon Mac, you may need to install Rosetta 2 (open terminal and run ```softwareupdate --install-rosetta```).
3. [Install Teensyduino](https://www.pjrc.com/teensy/td_download.html).
4. [Install the teensy4_i2c library](https://github.com/Richard-Gemmell/teensy4_i2c/blob/master/documentation/installation/arduino_installation.md).
5. Clone this repo onto your development machine and open the .ino file with the Arduino IDE.
6. In the "Tools" menu select "Teensy 4.0" as the board and the appropriate USB for the port.
7. Connect the Teensy to your laptop via USB and then click the "upload" button in the IDE to flash.

